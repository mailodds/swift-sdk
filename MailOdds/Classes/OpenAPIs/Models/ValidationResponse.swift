//
// ValidationResponse.swift
//
// Generated by openapi-generator
// https://openapi-generator.tech
//

import Foundation
#if canImport(AnyCodable)
import AnyCodable
#endif

/** Flat validation response. Conditional fields are omitted (not null) when not applicable. */
public struct ValidationResponse: Codable, JSONEncodable, Hashable {

    public enum Status: String, Codable, CaseIterable {
        case valid = "valid"
        case invalid = "invalid"
        case catchAll = "catch_all"
        case doNotMail = "do_not_mail"
        case unknown = "unknown"
    }
    public enum Action: String, Codable, CaseIterable {
        case accept = "accept"
        case acceptWithCaution = "accept_with_caution"
        case reject = "reject"
        case retryLater = "retry_later"
    }
    public enum SubStatus: String, Codable, CaseIterable {
        case formatInvalid = "format_invalid"
        case mxMissing = "mx_missing"
        case mxTimeout = "mx_timeout"
        case smtpUnreachable = "smtp_unreachable"
        case smtpRejected = "smtp_rejected"
        case disposable = "disposable"
        case roleAccount = "role_account"
        case greylisted = "greylisted"
        case catchAllDetected = "catch_all_detected"
        case suppressionMatch = "suppression_match"
    }
    public enum Depth: String, Codable, CaseIterable {
        case standard = "standard"
        case enhanced = "enhanced"
    }
    public var schemaVersion: String
    public var email: String
    /** Validation status */
    public var status: Status
    /** Recommended action */
    public var action: Action
    /** Detailed status reason. Omitted when none. */
    public var subStatus: SubStatus?
    public var domain: String
    /** Whether MX records were found for the domain */
    public var mxFound: Bool
    /** Primary MX hostname. Omitted when MX not resolved. */
    public var mxHost: String?
    /** Whether SMTP verification passed. Omitted when SMTP not checked. */
    public var smtpCheck: Bool?
    /** Whether domain is catch-all. Omitted when SMTP not checked. */
    public var catchAll: Bool?
    /** Whether domain is a known disposable email provider */
    public var disposable: Bool
    /** Whether address is a role account (e.g., info@, admin@) */
    public var roleAccount: Bool
    /** Whether domain is a known free email provider (e.g., gmail.com) */
    public var freeProvider: Bool
    /** Validation depth used for this check */
    public var depth: Depth
    /** ISO 8601 timestamp of validation */
    public var processedAt: Date
    /** Typo correction suggestion. Omitted when no typo detected. */
    public var suggestedEmail: String?
    /** Suggested retry delay in milliseconds. Present only for retry_later action. */
    public var retryAfterMs: Int?
    public var suppressionMatch: ValidationResponseSuppressionMatch?
    public var policyApplied: ValidationResponsePolicyApplied?

    public init(schemaVersion: String, email: String, status: Status, action: Action, subStatus: SubStatus? = nil, domain: String, mxFound: Bool, mxHost: String? = nil, smtpCheck: Bool? = nil, catchAll: Bool? = nil, disposable: Bool, roleAccount: Bool, freeProvider: Bool, depth: Depth, processedAt: Date, suggestedEmail: String? = nil, retryAfterMs: Int? = nil, suppressionMatch: ValidationResponseSuppressionMatch? = nil, policyApplied: ValidationResponsePolicyApplied? = nil) {
        self.schemaVersion = schemaVersion
        self.email = email
        self.status = status
        self.action = action
        self.subStatus = subStatus
        self.domain = domain
        self.mxFound = mxFound
        self.mxHost = mxHost
        self.smtpCheck = smtpCheck
        self.catchAll = catchAll
        self.disposable = disposable
        self.roleAccount = roleAccount
        self.freeProvider = freeProvider
        self.depth = depth
        self.processedAt = processedAt
        self.suggestedEmail = suggestedEmail
        self.retryAfterMs = retryAfterMs
        self.suppressionMatch = suppressionMatch
        self.policyApplied = policyApplied
    }

    public enum CodingKeys: String, CodingKey, CaseIterable {
        case schemaVersion = "schema_version"
        case email
        case status
        case action
        case subStatus = "sub_status"
        case domain
        case mxFound = "mx_found"
        case mxHost = "mx_host"
        case smtpCheck = "smtp_check"
        case catchAll = "catch_all"
        case disposable
        case roleAccount = "role_account"
        case freeProvider = "free_provider"
        case depth
        case processedAt = "processed_at"
        case suggestedEmail = "suggested_email"
        case retryAfterMs = "retry_after_ms"
        case suppressionMatch = "suppression_match"
        case policyApplied = "policy_applied"
    }

    // Encodable protocol methods

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encode(schemaVersion, forKey: .schemaVersion)
        try container.encode(email, forKey: .email)
        try container.encode(status, forKey: .status)
        try container.encode(action, forKey: .action)
        try container.encodeIfPresent(subStatus, forKey: .subStatus)
        try container.encode(domain, forKey: .domain)
        try container.encode(mxFound, forKey: .mxFound)
        try container.encodeIfPresent(mxHost, forKey: .mxHost)
        try container.encodeIfPresent(smtpCheck, forKey: .smtpCheck)
        try container.encodeIfPresent(catchAll, forKey: .catchAll)
        try container.encode(disposable, forKey: .disposable)
        try container.encode(roleAccount, forKey: .roleAccount)
        try container.encode(freeProvider, forKey: .freeProvider)
        try container.encode(depth, forKey: .depth)
        try container.encode(processedAt, forKey: .processedAt)
        try container.encodeIfPresent(suggestedEmail, forKey: .suggestedEmail)
        try container.encodeIfPresent(retryAfterMs, forKey: .retryAfterMs)
        try container.encodeIfPresent(suppressionMatch, forKey: .suppressionMatch)
        try container.encodeIfPresent(policyApplied, forKey: .policyApplied)
    }
}

